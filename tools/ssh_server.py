import argparse
import getpass
import paramiko
import os
import socket
import subprocess
import textwrap
import threading
import shlex
import subprocess
import sys

def execute(cmd):
    cmd = cmd.strip()
    print("cmd:" + cmd)
    if not cmd:
        return
    output = subprocess.check_output(shlex.split(cmd), stderr=subprocess.STDOUT, shell=True, encoding="850")

    return output

class Server(paramiko.ServerInterface):
    def __init__(self, username, password):
        self.event = threading.Event()
        self.username = username
        self.password = password

    def check_channel_request(self, kind, chanid):
        if kind == 'session':
            return paramiko.OPEN_SUCCEEDED
        return paramiko.OPEN_FAILED_ADMINISRTATIVELY_PROHIBITED

    def check_auth_password(self, username, password):
        if (username == self.username) and (password == self.password):
            return paramiko.AUTH_SUCCESSFUL


class SshServer:
    def __init__(self, args):
        self.target = args.target
        self.port = args.port
        self.cwd = os.path.dirname(os.path.realpath(__file__))
        self.key = paramiko.RSAKey(filename=os.path.join(self.cwd, args.key))
        self.event = threading.Event()
        self.username = input("Username: ")
        self.password = getpass.getpass()

    def check_channel_request(self, kind, chanid):
        if kind == 'session':
            return paramiko.OPEN_SUCCEEDED
        return paramiko.OPEN_FAILED_ADMINISRTATIVELY_PROHIBITED

    def check_auth_password(self, username, password):
        if (username == self.username) and (password == self.password):
            return paramiko.AUTH_SUCCESSFUL

    def run(self):
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            sock.bind((self.target, self.port))
            sock.listen(100)
            print('[+] Listening for connection ----')
            client, addr = sock.accept()
        except Exception as e:
            print('[-] Listen failed: ' + str(e))
            sys.exit(1)
        else:
            print('[+] Got a connection', client, addr)

        bhSession = paramiko.Transport(client)
        bhSession.add_server_key(self.key)
        server = Server(self.username, self.password)
        bhSession.start_server(server=server)

        chan = bhSession.accept(20)
        if chan is None:
            print("*** No channel.")
            sys.exit(1)

        print('[+] Authenticated!')
        cmd_buffer = b''
        while True:
            try:
                chan.send(b'Arthur: #> ')

                recv = chan.recv(64)
                recv_len = len(recv)
                cmd_buffer += recv
                response = execute(cmd_buffer.decode())
                if response:
                    chan.send(response.encode())
                cmd_buffer = b''
            except Exception as e:
                print(f'server killed {e}')
                chan.close()
                sys.exit()


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='My ssh server',
                                     formatter_class=argparse.RawDescriptionHelpFormatter,
                                     epilog=textwrap.dedent('''Example:
                                     ssh_server.py -t 192.168.1.2 -p 9999 -k key.key # lance un serveur ssh à l'adresse 192.168.1.2 et 
                                     sur le port 9999 avec la clé key.key pour chiffrer les transactions
                                     '''))
    parser.add_argument('-p', '--port', type=int, default=9999, help='specified port')
    parser.add_argument('-t', '--target', default='127.0.0.1', help='specified IP')
    parser.add_argument('-k', '--key', help='specified the key')
    args = parser.parse_args()

    ssh = SshServer(args)
    ssh.run()